# TabibDesk Project Rules

## Deployment & Build Requirements

### Critical Build Rules
1. **Type Checking Must Be Enabled**
   - Never disable TypeScript type checking in `next.config.mjs`
   - Keep `typescript.ignoreBuildErrors: false` at all times
   - Keep `eslint.ignoreDuringBuilds: false` at all times
   - If build fails with type errors, FIX the errors - don't disable checking

2. **Remove Dead Code, Don't Ignore Errors**
   - If components/files reference non-existent types or translation keys, DELETE them
   - Don't import components that aren't used in the page
   - Run `npm run typecheck` locally before committing
   - Build must succeed with full type checking enabled

3. **Dependency Management**
   - This project uses `npm`, NOT `pnpm` (despite pnpm-lock.yaml existing)
   - Always use `npm install` to add/update dependencies
   - If `pnpm-lock.yaml` exists and gets out of sync, either:
     - Update it with `pnpm install --no-frozen-lockfile` OR
     - Delete it and use npm exclusively
   - Netlify CI expects lockfiles to be in sync with package.json

4. **Registry Configuration**
   - Project `.npmrc` should only contain: `legacy-peer-deps=true`
   - For public packages like @dnd-kit, ensure they're fetched from public npm registry
   - If global `.npmrc` has private registry config, override in project `.npmrc`:
     ```
     @dnd-kit:registry=https://registry.npmjs.org/
     ```

### Type Safety Rules
1. **Null Safety**
   - Mock data fields like `clinic_id`, `doctor_id` can be `null`
   - Always handle with `|| ""` fallback when passing to APIs
   - Example: `appointment.clinic_id || ""`

2. **Type Consistency**
   - Badge component uses: `error`, `warning`, `success`, `neutral`, `default`
   - Button component uses: `primary`, `secondary`, `destructive`, `ghost`, `light`, `outline`
   - Never use `variant="error"` on Button - use `variant="destructive"`
   - Keep "arrived" status in all Appointment type definitions

3. **Component Props**
   - All required props must be provided
   - Check component interfaces before using them
   - Example: `SidebarUserProfile` requires `mode` prop

## Tremor Components

Prefer Tremor components whenever possible before building new custom components. Tremor provides charts, cards, metric displays, and other UI primitives—check the Tremor library first and use existing components before creating custom implementations. Only build custom components when Tremor does not offer a suitable option.

### Pre-Deployment Checklist
Before pushing to production:
- [ ] Run `npm run build` locally and ensure it succeeds
- [ ] Run `npm run typecheck` and fix all errors
- [ ] Check that all imports are actually used
- [ ] Verify no dead code exists (unused components/functions)
- [ ] Ensure lockfile matches package.json
- [ ] Test that landing page works (only active components should exist)

### Netlify Specific
- Build command: `npm run build`
- Publish directory: `.next`
- Node version: 18.x
- TypeScript checking is ENABLED in build
- ESLint is ENABLED in build
- Images: `unoptimized: true` in next.config.mjs (required for Netlify)
- Public folder images are served from root (e.g., `/landing/image.jpg`)

## Backend & Supabase (Database)

Multi-tenant clinic SaaS: follow these Supabase/Postgres rules.

### Edge Functions vs client/DB
- **Edge Functions**: external APIs (WhatsApp, Clawd, payments), PDFs, webhooks, anything needing **service role**. Do not use for simple CRUD—use client + RLS.

### Business logic (RPC)
- **Postgres functions (RPC)** for: multi-step transactions (e.g. invoice + line items + payment), calculated summaries, heavy dashboard queries. Use only when atomicity or performance requires it.

### Security (RLS first)
- **RLS on every tenant-scoped table.** Expose only what the user is allowed to do via RLS.
- Use **SECURITY DEFINER** sparingly; keep functions narrow and validate clinic membership inside them.
- Client reads/writes with RLS; functions do privileged work only after validating membership.

### Multi-tenancy: always pass `clinic_id`
- Every tenant table has `clinic_id`. Every insert/update includes it; every query filters by it.
- Enforce in DB policies; do not rely on “current clinic” from UI only.

### Helper functions for policies
- Use small SQL helpers (e.g. `is_member(clinic_id)`, `has_role(clinic_id, 'manager')`) in RLS policies and RPCs.

### Avoid N+1 and heavy client joins
- For dashboards/insights: use a **view** or **RPC** that returns the full payload. Aim for 1–2 queries per page from the client.

### Storage
- Use Supabase Storage with paths like `clinic/{clinic_id}/patients/{patient_id}/...`. Use **signed URLs** for private files. Keep metadata in a `files` table (clinic_id, patient_id, type, url/path).

### Triggers
- Use DB triggers for “always true” behavior (e.g. `updated_at`, optional activity_log). Keep triggers small and predictable.

### Integrations (outbox)
- For events that drive integrations (e.g. appointment cancelled, due created): insert into `outbox_events`; let an Edge Function consume and notify (Clawd, WhatsApp). Keeps automations reliable.

### Local dev & versioning
- All schema and logic in code: migrations in `supabase/migrations/`, Edge Functions in `supabase/functions/`. Do not rely on one-off changes in the dashboard without migrating them back.

## Font Hierarchy

When creating new components, always follow the font hierarchy established in `src/features/patients/PatientsPage.tsx`:

### Standard Font Sizes

1. **Headers/Titles** (Table headers, Card titles):
   - `text-sm font-semibold` for table headers
   - `text-lg` for card titles (when using CardTitle component)

2. **Primary Content** (Main text, patient names, important labels):
   - `text-sm font-medium` for patient names in list/table views (matches phone/last appointment size)
   - `font-medium` (base size) for patient names in detailed views
   - `text-sm font-semibold` for smaller emphasis

3. **Secondary Information** (Metadata, descriptions, supporting text):
   - `text-sm` for phone numbers, dates, and secondary details
   - `text-xs` for age/gender, complaint labels, and smaller metadata

4. **Small Labels/Badges** (Time badges, status indicators, badges):
   - `text-xs` for badges, time indicators, and small labels
   - Use `font-bold` with `text-xs` for emphasis on small text

### Examples from PatientsPage

- **Table Header**: `text-sm font-semibold`
- **Patient Name (Table)**: `font-medium` (base size) - for detailed table views
- **Patient Name (List/Queue)**: `text-sm font-medium` - for compact list/queue views
- **Age/Gender**: `text-xs`
- **Complaint**: `text-xs`
- **Phone**: `text-sm`
- **Last Appointment**: `text-sm`
- **Card Title**: `text-lg`
- **Card Description**: `text-xs`

### Important Rules

- **Never use arbitrary font sizes** like `text-[8px]`, `text-[9px]`, `text-[10px]` - always use standard Tailwind classes: `text-xs`, `text-sm`, `text-base`, `text-lg`
- **Consistent hierarchy**: Primary content should be larger than secondary content
- **Badges and small labels**: Use `text-xs` minimum, never smaller
- **Time indicators**: Use `text-xs` with `font-bold` and `uppercase tracking-widest` for time badges

## Dashboard & Widget Standards

Widgets (like Now Queue and Today's Appointments) have a specific "dense" design language that differs from full-page tables:

1. **Alignment & Density**:
   - Use `items-end` for row vertical alignment (bottom-heavy).
   - Use tight gaps (`gap-1.5`) between content elements.
   - Use `px-4 py-4` for widget row padding.

2. **Global Widget Styles**:
   - **Always** use global classes from `globals.css` instead of inline Tailwind:
     - Buttons: `.btn-primary-widget`, `.btn-secondary-widget`.
     - Rows: `.widget-row`.
     - Content Stacks: `.widget-content-stack`.
     - Text: `.text-widget-title`, `.text-widget-description`, `.text-widget-metadata`.

3. **Text Transformation**:
   - Widgets use **lowercase only** for status text, labels, and metadata (no capitalization/uppercase).

4. **Data Integrity**:
   - Never use inline mocked data within components.
   - Always fetch from the `mock/` data layer or API.

### Reference Implementation

See `src/features/patients/PatientsTable.tsx` and `src/features/patients/PatientsCards.tsx` for canonical examples of proper font hierarchy usage.
See `src/app/(app)/dashboard/page.tsx` for the canonical widget implementation.

## RTL & i18n (Internationalization)

**Every new component must support RTL (right-to-left) and use translations.** The app targets Arabic (Egyptian dialect) as primary language.

### RTL Design Rules

1. **Document Direction**:
   - `LocaleSync` syncs `dir` and `lang` to `document.documentElement`. When `lang === "ar"`, `dir="rtl"` is applied automatically.
   - Most layout auto-flips with `dir="rtl"`; use logical properties for explicit control.

2. **Logical CSS Properties** (prefer over directional):
   - Use `ms-*`, `me-*` (margin-inline-start/end), `ps-*`, `pe-*` (padding-inline-start/end) instead of `ml/mr`, `pl/pr`.
   - Use `start`, `end` in flex/grid alignment instead of `left`, `right`.
   - Use `rounded-s-*`, `rounded-e-*` for directional radius when needed.

3. **Direction-Aware Components**:
   - For components with asymmetric layout (drawers, sidebars, tooltips), use `useLocale()` → `isRtl` and flip as needed.
   - Example: `side={isRtl ? "left" : "right"}` for drawers (see `BookAppointmentDrawer.tsx`).
   - Icons that imply direction (arrows, chevrons) should flip in RTL—use `rtl:rotate-180` or mirror variants when appropriate.

4. **Never hardcode `left`/`right`** for layout that should flip in RTL; use logical properties or `isRtl` checks.

### Translations (Egyptian Dialect)

1. **All user-facing strings must be translated — no hardcoded UI text**:
   - **Never** hardcode user-visible strings (labels, titles, buttons, placeholders, tooltips, `title=`, `aria-label=`, modal/dialog text, etc.) in components.
   - Always use `useAppTranslations()` to access translations.
   - Add every new user-facing string to `src/lib/app-translations.ts` in **both** `ar` and `en` objects before using it in the UI.
   - When adding a new feature or component, add all required translation keys first, then reference them via `t.*` in the component.

2. **Egyptian Arabic dialect**:
   - Use Egyptian colloquial Arabic (عامية مصرية) for `ar` keys, not formal Modern Standard Arabic.
   - Examples: "دلوقتي" (now), "النّهاردة" (today), "مفيش" (there isn't), "عايز" (want), "إيه" (what), "إزاي" (how).
   - Match the existing tone in `app-translations.ts` (conversational, clinic-appropriate).

3. **Key organization**:
   - Group keys by feature (e.g. `dashboard`, `patients`, `appointments`, `common`).
   - Use nested objects for related strings.
   - Keep keys semantic: `modalNoShowTitle` not `title1`.

4. **Checklist for new UI**:
   - Buttons, links, labels, placeholders → translation key.
   - Modal/drawer titles and descriptions → translation key.
   - Tooltips (`title=`), `aria-label` → translation key.
   - Error/success messages → translation key.
   - If a string is shown to the user, it must come from `app-translations.ts`.

### Reference Files

- `src/contexts/locale-context.tsx` — `useLocale()`, `isRtl`, `dir`, `lang`
- `src/lib/useAppTranslations.ts` — `useAppTranslations()` hook
- `src/lib/app-translations.ts` — translation keys (ar/en)
- `src/features/appointments/components/BookAppointmentDrawer.tsx` — RTL-aware drawer side
